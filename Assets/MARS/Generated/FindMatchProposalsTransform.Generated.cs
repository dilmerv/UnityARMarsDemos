// This file is automatically generated - DO NOT EDIT MANUALLY!
using System.Collections.Generic;
using Unity.MARS.Data;

namespace Unity.MARS.Query
{
    partial class FindMatchProposalsTransform
    {
        internal static void GetStartingIdSet(ConditionRatingsData data, HashSet<int> idSet)
        {
            idSet.Clear();
            var tagRatings = data[typeof(bool)];
            if (tagRatings != null && tagRatings.Count > 0)
            {
                for (var i = 0; i < tagRatings.Count; i++)
                {
                    // If we're excluding, we can't use this set as the starting point
                    if (data.MatchRuleIndexes[i] == SemanticTagMatchRule.Exclude)
                        continue;

                    var dictionary = tagRatings[i];
                    foreach (var kvp in dictionary)
                    {
                        idSet.Add(kvp.Key);
                    }

                    return;
                }
            }

            var intRatings = data[typeof(System.Int32)];
            if (intRatings != null && intRatings.Count > 0)
            {
                foreach (var kvp in intRatings[0])
                {
                    idSet.Add(kvp.Key);
                }

                return;
            }

            var floatRatings = data[typeof(System.Single)];
            if (floatRatings != null && floatRatings.Count > 0)
            {
                foreach (var kvp in floatRatings[0])
                {
                    idSet.Add(kvp.Key);
                }

                return;
            }

            var stringRatings = data[typeof(System.String)];
            if (stringRatings != null && stringRatings.Count > 0)
            {
                foreach (var kvp in stringRatings[0])
                {
                    idSet.Add(kvp.Key);
                }

                return;
            }

            var poseRatings = data[typeof(UnityEngine.Pose)];
            if (poseRatings != null && poseRatings.Count > 0)
            {
                foreach (var kvp in poseRatings[0])
                {
                    idSet.Add(kvp.Key);
                }

                return;
            }

            var vector2Ratings = data[typeof(UnityEngine.Vector2)];
            if (vector2Ratings != null && vector2Ratings.Count > 0)
            {
                foreach (var kvp in vector2Ratings[0])
                {
                    idSet.Add(kvp.Key);
                }

                return;
            }
        }

        static bool FindIntersection(ConditionRatingsData data, HashSet<int> matchSet)
        {
            var intData = data[typeof(System.Int32)];
            if (intData != null)
            {
                foreach (var dictionary in intData)
                {
                    k_IDsMatchingCondition.Clear();
                    foreach (var kvp in dictionary)
                    {
                        k_IDsMatchingCondition.Add(kvp.Key);
                    }

                    matchSet.IntersectWith(k_IDsMatchingCondition);
                }
            }

            if (matchSet.Count == 0)
                return false;

            var floatData = data[typeof(System.Single)];
            if (floatData != null)
            {
                foreach (var dictionary in floatData)
                {
                    k_IDsMatchingCondition.Clear();
                    foreach (var kvp in dictionary)
                    {
                        k_IDsMatchingCondition.Add(kvp.Key);
                    }

                    matchSet.IntersectWith(k_IDsMatchingCondition);
                }
            }

            if (matchSet.Count == 0)
                return false;

            var stringData = data[typeof(System.String)];
            if (stringData != null)
            {
                foreach (var dictionary in stringData)
                {
                    k_IDsMatchingCondition.Clear();
                    foreach (var kvp in dictionary)
                    {
                        k_IDsMatchingCondition.Add(kvp.Key);
                    }

                    matchSet.IntersectWith(k_IDsMatchingCondition);
                }
            }

            if (matchSet.Count == 0)
                return false;

            var poseData = data[typeof(UnityEngine.Pose)];
            if (poseData != null)
            {
                foreach (var dictionary in poseData)
                {
                    k_IDsMatchingCondition.Clear();
                    foreach (var kvp in dictionary)
                    {
                        k_IDsMatchingCondition.Add(kvp.Key);
                    }

                    matchSet.IntersectWith(k_IDsMatchingCondition);
                }
            }

            if (matchSet.Count == 0)
                return false;

            var vector2Data = data[typeof(UnityEngine.Vector2)];
            if (vector2Data != null)
            {
                foreach (var dictionary in vector2Data)
                {
                    k_IDsMatchingCondition.Clear();
                    foreach (var kvp in dictionary)
                    {
                        k_IDsMatchingCondition.Add(kvp.Key);
                    }

                    matchSet.IntersectWith(k_IDsMatchingCondition);
                }
            }

            if (matchSet.Count == 0)
                return false;

            return true;
        }
    }
}
